# src/ui/main_window.py
"""
メインウィンドウモジュール
アプリケーションのメインインターフェース
"""

import sys
import os
from typing import Dict, List, Optional, Any
from pathlib import Path
from datetime import datetime
import json

from PyQt6.QtWidgets import (
    QMainWindow, QApplication, QWidget, QVBoxLayout, QHBoxLayout,
    QSplitter, QMenuBar, QMenu, QToolBar, QStatusBar, QLabel,
    QMessageBox, QFileDialog, QProgressBar, QTabWidget,
    QDockWidget, QTextEdit, QAction, QActionGroup
)
from PyQt6.QtCore import (
    Qt, QTimer, QThread, pyqtSignal, QSettings, QSize, QPoint,
    QPropertyAnimation, QEasingCurve, QRect
)
from PyQt6.QtGui import (
    QIcon, QPixmap, QFont, QFontMetrics, QKeySequence,
    QShortcut, QPalette, QColor, QAction as QGuiAction
)

from ..core.logger import get_logger
from ..core.config_manager import get_config_manager
from ..core.project_manager import get_project_manager
from ..core.event_system import get_event_system, EventType
from ..llm.llm_factory import get_llm_factory
from .code_editor import CodeEditor
from .project_tree import ProjectTree
from .chat_panel import ChatPanel
from .settings_dialog import SettingsDialog
from .about_dialog import AboutDialog
from .progress_dialog import ProgressDialog
from .find_replace_dialog import FindReplaceDialog
from .components.theme_manager import get_theme_manager
from .components.custom_widgets import StatusBarWidget, ToolBarWidget

logger = get_logger(__name__)

class MainWindow(QMainWindow):
    """メインウィンドウクラス"""
    
    # シグナル定義
    project_opened = pyqtSignal(str)  # プロジェクトが開かれた
    project_closed = pyqtSignal()     # プロジェクトが閉じられた
    file_opened = pyqtSignal(str)     # ファイルが開かれた
    file_saved = pyqtSignal(str)      # ファイルが保存された
    theme_changed = pyqtSignal(str)   # テーマが変更された
    
    def __init__(self):
        """初期化"""
        super().__init__()
        
        self.logger = get_logger(self.__class__.__name__)
        self.config_manager = get_config_manager()
        self.project_manager = get_project_manager()
        self.event_system = get_event_system()
        self.theme_manager = get_theme_manager()
        self.llm_factory = get_llm_factory()
        
        # 設定
        self.settings = QSettings('LLMCodeAssistant', 'MainWindow')
        
        # UI要素
        self.central_widget: Optional[QWidget] = None
        self.main_splitter: Optional[QSplitter] = None
        self.code_splitter: Optional[QSplitter] = None
        self.project_tree: Optional[ProjectTree] = None
        self.code_editor: Optional[CodeEditor] = None
        self.chat_panel: Optional[ChatPanel] = None
        self.tab_widget: Optional[QTabWidget] = None
        
        # ダイアログ
        self.settings_dialog: Optional[SettingsDialog] = None
        self.about_dialog: Optional[AboutDialog] = None
        self.progress_dialog: Optional[ProgressDialog] = None
        self.find_replace_dialog: Optional[FindReplaceDialog] = None
        
        # 状態管理
        self.current_project_path: Optional[str] = None
        self.current_file_path: Optional[str] = None
        self.recent_files: List[str] = []
        self.recent_projects: List[str] = []
        self.is_modified: bool = False
        
        # アニメーション
        self.animations: Dict[str, QPropertyAnimation] = {}
        
        # 初期化
        self._init_ui()
        self._init_menus()
        self._init_toolbars()
        self._init_statusbar()
        self._init_shortcuts()
        self._init_connections()
        self._load_settings()
        self._apply_theme()
        
        self.logger.info("メインウィンドウを初期化しました")
    
    def _init_ui(self):
        """UIを初期化"""
        try:
            # ウィンドウ設定
            self.setWindowTitle("LLM Code Assistant")
            self.setWindowIcon(QIcon("assets/icons/app_icon.ico"))
            self.setMinimumSize(1200, 800)
            self.resize(1600, 1000)
            
            # 中央ウィジェット
            self.central_widget = QWidget()
            self.setCentralWidget(self.central_widget)
            
            # メインレイアウト
            main_layout = QHBoxLayout(self.central_widget)
            main_layout.setContentsMargins(5, 5, 5, 5)
            main_layout.setSpacing(5)
            
            # メインスプリッター（水平）
            self.main_splitter = QSplitter(Qt.Orientation.Horizontal)
            main_layout.addWidget(self.main_splitter)
            
            # プロジェクトツリー
            self.project_tree = ProjectTree()
            self.main_splitter.addWidget(self.project_tree)
            
            # コードエリアスプリッター（垂直）
            self.code_splitter = QSplitter(Qt.Orientation.Vertical)
            self.main_splitter.addWidget(self.code_splitter)
            
            # タブウィジェット（コードエディタ用）
            self.tab_widget = QTabWidget()
            self.tab_widget.setTabsClosable(True)
            self.tab_widget.setMovable(True)
            self.tab_widget.setDocumentMode(True)
            self.code_splitter.addWidget(self.tab_widget)
            
            # チャットパネル
            self.chat_panel = ChatPanel()
            self.code_splitter.addWidget(self.chat_panel)
            
            # 初期コードエディタを追加
            self._add_new_editor("無題")
            
            # スプリッターサイズを設定
            self.main_splitter.setSizes([250, 1350])
            self.code_splitter.setSizes([600, 400])
            
            # スプリッター設定
            self.main_splitter.setChildrenCollapsible(False)
            self.code_splitter.setChildrenCollapsible(False)
            
        except Exception as e:
            self.logger.error(f"UI初期化エラー: {e}")
            raise
    
    def _init_menus(self):
        """メニューを初期化"""
        try:
            menubar = self.menuBar()
            
            # ファイルメニュー
            file_menu = menubar.addMenu("ファイル(&F)")
            
            # 新規作成
            new_action = QAction("新規作成(&N)", self)
            new_action.setShortcut(QKeySequence.StandardKey.New)
            new_action.setIcon(QIcon("assets/icons/toolbar_icons/new.png"))
            new_action.triggered.connect(self._new_file)
            file_menu.addAction(new_action)
            
            # 開く
            open_action = QAction("開く(&O)", self)
            open_action.setShortcut(QKeySequence.StandardKey.Open)
            open_action.setIcon(QIcon("assets/icons/toolbar_icons/open.png"))
            open_action.triggered.connect(self._open_file)
            file_menu.addAction(open_action)
            
            file_menu.addSeparator()
            
            # 保存
            save_action = QAction("保存(&S)", self)
            save_action.setShortcut(QKeySequence.StandardKey.Save)
            save_action.setIcon(QIcon("assets/icons/toolbar_icons/save.png"))
            save_action.triggered.connect(self._save_file)
            file_menu.addAction(save_action)
            
            # 名前を付けて保存
            save_as_action = QAction("名前を付けて保存(&A)", self)
            save_as_action.setShortcut(QKeySequence.StandardKey.SaveAs)
            save_as_action.triggered.connect(self._save_file_as)
            file_menu.addAction(save_as_action)
            
            file_menu.addSeparator()
            
            # 最近のファイル
            recent_files_menu = file_menu.addMenu("最近のファイル(&R)")
            self._update_recent_files_menu(recent_files_menu)
            
            file_menu.addSeparator()
            
            # 終了
            exit_action = QAction("終了(&X)", self)
            exit_action.setShortcut(QKeySequence.StandardKey.Quit)
            exit_action.triggered.connect(self.close)
            file_menu.addAction(exit_action)
            
            # 編集メニュー
            edit_menu = menubar.addMenu("編集(&E)")
            
            # 元に戻す
            undo_action = QAction("元に戻す(&U)", self)
            undo_action.setShortcut(QKeySequence.StandardKey.Undo)
            undo_action.triggered.connect(self._undo)
            edit_menu.addAction(undo_action)
            
            # やり直し
            redo_action = QAction("やり直し(&R)", self)
            redo_action.setShortcut(QKeySequence.StandardKey.Redo)
            redo_action.triggered.connect(self._redo)
            edit_menu.addAction(redo_action)
            
            edit_menu.addSeparator()
            
            # 切り取り
            cut_action = QAction("切り取り(&T)", self)
            cut_action.setShortcut(QKeySequence.StandardKey.Cut)
            cut_action.setIcon(QIcon("assets/icons/toolbar_icons/cut.png"))
            cut_action.triggered.connect(self._cut)
            edit_menu.addAction(cut_action)
            
            # コピー
            copy_action = QAction("コピー(&C)", self)
            copy_action.setShortcut(QKeySequence.StandardKey.Copy)
            copy_action.setIcon(QIcon("assets/icons/toolbar_icons/copy.png"))
            copy_action.triggered.connect(self._copy)
            edit_menu.addAction(copy_action)
            
            # 貼り付け
            paste_action = QAction("貼り付け(&P)", self)
            paste_action.setShortcut(QKeySequence.StandardKey.Paste)
            paste_action.setIcon(QIcon("assets/icons/toolbar_icons/paste.png"))
            paste_action.triggered.connect(self._paste)
            edit_menu.addAction(paste_action)
            
            edit_menu.addSeparator()
            
            # 検索・置換
            find_action = QAction("検索・置換(&F)", self)
            find_action.setShortcut(QKeySequence.StandardKey.Find)
            find_action.triggered.connect(self._show_find_replace)
            edit_menu.addAction(find_action)
            
            # プロジェクトメニュー
            project_menu = menubar.addMenu("プロジェクト(&P)")
            
            # プロジェクトを開く
            open_project_action = QAction("プロジェクトを開く(&O)", self)
            open_project_action.triggered.connect(self._open_project)
            project_menu.addAction(open_project_action)
            
            # プロジェクトを閉じる
            close_project_action = QAction("プロジェクトを閉じる(&C)", self)
            close_project_action.triggered.connect(self._close_project)
            project_menu.addAction(close_project_action)
            
            project_menu.addSeparator()
            
            # 最近のプロジェクト
            recent_projects_menu = project_menu.addMenu("最近のプロジェクト(&R)")
            self._update_recent_projects_menu(recent_projects_menu)
            
            # LLMメニュー
            llm_menu = menubar.addMenu("LLM(&L)")
            
            # モデル選択
            model_menu = llm_menu.addMenu("モデル選択(&M)")
            self._init_model_menu(model_menu)
            
            llm_menu.addSeparator()
            
            # コード生成
            generate_action = QAction("コード生成(&G)", self)
            generate_action.setShortcut("Ctrl+G")
            generate_action.triggered.connect(self._generate_code)
            llm_menu.addAction(generate_action)
            
            # コードレビュー
            review_action = QAction("コードレビュー(&R)", self)
            review_action.setShortcut("Ctrl+R")
            review_action.triggered.connect(self._review_code)
            llm_menu.addAction(review_action)
            
            # コード説明
            explain_action = QAction("コード説明(&E)", self)
            explain_action.setShortcut("Ctrl+E")
            explain_action.triggered.connect(self._explain_code)
            llm_menu.addAction(explain_action)
            
            # 表示メニュー
            view_menu = menubar.addMenu("表示(&V)")
            
            # テーマ選択
            theme_menu = view_menu.addMenu("テーマ(&T)")
            self._init_theme_menu(theme_menu)
            
            view_menu.addSeparator()
            
            # パネル表示切替
            toggle_project_action = QAction("プロジェクトツリー(&P)", self)
            toggle_project_action.setCheckable(True)
            toggle_project_action.setChecked(True)
            toggle_project_action.triggered.connect(self._toggle_project_tree)
            view_menu.addAction(toggle_project_action)
            
            toggle_chat_action = QAction("チャットパネル(&C)", self)
            toggle_chat_action.setCheckable(True)
            toggle_chat_action.setChecked(True)
            toggle_chat_action.triggered.connect(self._toggle_chat_panel)
            view_menu.addAction(toggle_chat_action)
            
            # ヘルプメニュー
            help_menu = menubar.addMenu("ヘルプ(&H)")
            
            # ユーザーガイド
            user_guide_action = QAction("ユーザーガイド(&U)", self)
            user_guide_action.triggered.connect(self._show_user_guide)
            help_menu.addAction(user_guide_action)
            
            # API リファレンス
            api_ref_action = QAction("API リファレンス(&A)", self)
            api_ref_action.triggered.connect(self._show_api_reference)
            help_menu.addAction(api_ref_action)
            
            help_menu.addSeparator()
            
            # バージョン情報
            about_action = QAction("バージョン情報(&A)", self)
            about_action.triggered.connect(self._show_about)
            help_menu.addAction(about_action)
            
        except Exception as e:
            self.logger.error(f"メニュー初期化エラー: {e}")
            raise
    
    def _init_toolbars(self):
        """ツールバーを初期化"""
        try:
            # メインツールバー
            main_toolbar = self.addToolBar("メイン")
            main_toolbar.setObjectName("MainToolBar")
            main_toolbar.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextUnderIcon)
            
            # 新規作成
            new_action = QAction(QIcon("assets/icons/toolbar_icons/new.png"), "新規", self)
            new_action.triggered.connect(self._new_file)
            main_toolbar.addAction(new_action)
            
            # 開く
            open_action = QAction(QIcon("assets/icons/toolbar_icons/open.png"), "開く", self)
            open_action.triggered.connect(self._open_file)
            main_toolbar.addAction(open_action)
            
            # 保存
            save_action = QAction(QIcon("assets/icons/toolbar_icons/save.png"), "保存", self)
            save_action.triggered.connect(self._save_file)
            main_toolbar.addAction(save_action)
            
            main_toolbar.addSeparator()
            
            # 切り取り
            cut_action = QAction(QIcon("assets/icons/toolbar_icons/cut.png"), "切り取り", self)
            cut_action.triggered.connect(self._cut)
            main_toolbar.addAction(cut_action)
            
            # コピー
            copy_action = QAction(QIcon("assets/icons/toolbar_icons/copy.png"), "コピー", self)
            copy_action.triggered.connect(self._copy)
            main_toolbar.addAction(copy_action)
            
            # 貼り付け
            paste_action = QAction(QIcon("assets/icons/toolbar_icons/paste.png"), "貼り付け", self)
            paste_action.triggered.connect(self._paste)
            main_toolbar.addAction(paste_action)
            
            main_toolbar.addSeparator()
            
            # 設定
            settings_action = QAction(QIcon("assets/icons/toolbar_icons/settings.png"), "設定", self)
            settings_action.triggered.connect(self._show_settings)
            main_toolbar.addAction(settings_action)
            
        except Exception as e:
            self.logger.error(f"ツールバー初期化エラー: {e}")
            raise
    
    def _init_statusbar(self):
        """ステータスバーを初期化"""
        try:
            statusbar = self.statusBar()
            
            # メインメッセージ
            self.status_label = QLabel("準備完了")
            statusbar.addWidget(self.status_label)
            
            # プログレスバー
            self.progress_bar = QProgressBar()
            self.progress_bar.setVisible(False)
            self.progress_bar.setMaximumWidth(200)
            statusbar.addPermanentWidget(self.progress_bar)
            
            # ファイル情報
            self.file_info_label = QLabel("")
            statusbar.addPermanentWidget(self.file_info_label)
            
            # カーソル位置
            self.cursor_label = QLabel("行: 1, 列: 1")
            statusbar.addPermanentWidget(self.cursor_label)
            
            # LLMモデル情報
            self.model_label = QLabel("モデル: 未選択")
            statusbar.addPermanentWidget(self.model_label)
            
        except Exception as e:
            self.logger.error(f"ステータスバー初期化エラー: {e}")
            raise
    
    def _init_shortcuts(self):
        """ショートカットを初期化"""
        try:
            # カスタムショートカット
            shortcuts = [
                ("Ctrl+Shift+P", self._show_command_palette),
                ("Ctrl+`", self._toggle_chat_panel),
                ("F11", self._toggle_fullscreen),
                ("Ctrl+Shift+T", self._reopen_closed_tab),
                ("Ctrl+W", self._close_current_tab),
                ("Ctrl+Shift+N", self._new_window),
            ]
            
            for key_sequence, slot in shortcuts:
                shortcut = QShortcut(QKeySequence(key_sequence), self)
                shortcut.activated.connect(slot)
            
        except Exception as e:
            self.logger.error(f"ショートカット初期化エラー: {e}")
    
    def _init_connections(self):
        """シグナル・スロット接続を初期化"""
        try:
            # タブウィジェット
            self.tab_widget.tabCloseRequested.connect(self._close_tab)
            self.tab_widget.currentChanged.connect(self._tab_changed)
            
            # プロジェクトツリー
            self.project_tree.file_double_clicked.connect(self._open_file_from_tree)
            self.project_tree.project_opened.connect(self._on_project_opened)
            
            # チャットパネル
            self.chat_panel.message_sent.connect(self._on_chat_message)
            self.chat_panel.code_generated.connect(self._on_code_generated)
            
            # イベントシステム
            self.event_system.subscribe(EventType.FILE_OPENED, self._on_file_opened_event)
            self.event_system.subscribe(EventType.FILE_SAVED, self._on_file_saved_event)
            self.event_system.subscribe(EventType.PROJECT_OPENED, self._on_project_opened_event)
            
        except Exception as e:
            self.logger.error(f"接続初期化エラー: {e}")
    
    def _init_model_menu(self, menu: QMenu):
        """モデル選択メニューを初期化"""
        try:
            model_group = QActionGroup(self)
            
            # 利用可能なモデルを取得
            available_models = self.llm_factory.get_available_models()
            
            for model_name in available_models:
                action = QAction(model_name, self)
                action.setCheckable(True)
                action.setActionGroup(model_group)
                action.triggered.connect(lambda checked, name=model_name: self._select_model(name))
                menu.addAction(action)
            
            # デフォルトモデルを選択
            if available_models:
                menu.actions()[0].setChecked(True)
                self._select_model(available_models[0])
            
        except Exception as e:
            self.logger.error(f"モデルメニュー初期化エラー: {e}")
    
    def _init_theme_menu(self, menu: QMenu):
        """テーマ選択メニューを初期化"""
        try:
            theme_group = QActionGroup(self)
            
            # 利用可能なテーマを取得
            available_themes = self.theme_manager.get_available_themes()
            
            for theme_name in available_themes:
                action = QAction(theme_name, self)
                action.setCheckable(True)
                action.setActionGroup(theme_group)
                action.triggered.connect(lambda checked, name=theme_name: self._select_theme(name))
                menu.addAction(action)
            
            # 現在のテーマを選択
            current_theme = self.theme_manager.get_current_theme()
            for action in menu.actions():
                if action.text() == current_theme:
                    action.setChecked(True)
                    break
            
        except Exception as e:
            self.logger.error(f"テーマメニュー初期化エラー: {e}")

    def _load_settings(self):
        """設定を読み込み"""
        try:
            # ウィンドウ設定
            geometry = self.settings.value("geometry")
            if geometry:
                self.restoreGeometry(geometry)
            
            window_state = self.settings.value("windowState")
            if window_state:
                self.restoreState(window_state)
            
            # スプリッター設定
            main_splitter_state = self.settings.value("mainSplitterState")
            if main_splitter_state:
                self.main_splitter.restoreState(main_splitter_state)
            
            code_splitter_state = self.settings.value("codeSplitterState")
            if code_splitter_state:
                self.code_splitter.restoreState(code_splitter_state)
            
            # 最近のファイル・プロジェクト
            self.recent_files = self.settings.value("recentFiles", [])
            self.recent_projects = self.settings.value("recentProjects", [])
            
            # 最後に開いていたプロジェクト
            last_project = self.settings.value("lastProject")
            if last_project and os.path.exists(last_project):
                self._open_project_path(last_project)
            
        except Exception as e:
            self.logger.error(f"設定読み込みエラー: {e}")
    
    def _save_settings(self):
        """設定を保存"""
        try:
            # ウィンドウ設定
            self.settings.setValue("geometry", self.saveGeometry())
            self.settings.setValue("windowState", self.saveState())
            
            # スプリッター設定
            self.settings.setValue("mainSplitterState", self.main_splitter.saveState())
            self.settings.setValue("codeSplitterState", self.code_splitter.saveState())
            
            # 最近のファイル・プロジェクト
            self.settings.setValue("recentFiles", self.recent_files)
            self.settings.setValue("recentProjects", self.recent_projects)
            
            # 現在のプロジェクト
            if self.current_project_path:
                self.settings.setValue("lastProject", self.current_project_path)
            
        except Exception as e:
            self.logger.error(f"設定保存エラー: {e}")
    
    def _apply_theme(self):
        """テーマを適用"""
        try:
            current_theme = self.theme_manager.get_current_theme()
            theme_data = self.theme_manager.get_theme_data(current_theme)
            
            if theme_data:
                # スタイルシートを適用
                self.setStyleSheet(theme_data.get('stylesheet', ''))
                
                # カスタムプロパティを設定
                properties = theme_data.get('properties', {})
                for key, value in properties.items():
                    self.setProperty(key, value)
                
                self.logger.info(f"テーマ '{current_theme}' を適用しました")
            
        except Exception as e:
            self.logger.error(f"テーマ適用エラー: {e}")
    
    # ファイル操作メソッド
    def _new_file(self):
        """新規ファイル作成"""
        try:
            editor = self._add_new_editor("無題")
            self.tab_widget.setCurrentWidget(editor)
            self.status_label.setText("新しいファイルを作成しました")
            
        except Exception as e:
            self.logger.error(f"新規ファイル作成エラー: {e}")
            QMessageBox.critical(self, "エラー", f"新規ファイルの作成に失敗しました: {e}")
    
    def _open_file(self):
        """ファイルを開く"""
        try:
            file_path, _ = QFileDialog.getOpenFileName(
                self,
                "ファイルを開く",
                "",
                "すべてのファイル (*);;Python ファイル (*.py);;JavaScript ファイル (*.js);;HTML ファイル (*.html);;CSS ファイル (*.css)"
            )
            
            if file_path:
                self._open_file_path(file_path)
            
        except Exception as e:
            self.logger.error(f"ファイルオープンエラー: {e}")
            QMessageBox.critical(self, "エラー", f"ファイルを開けませんでした: {e}")
    
    def _open_file_path(self, file_path: str):
        """指定されたパスのファイルを開く"""
        try:
            # 既に開いているかチェック
            for i in range(self.tab_widget.count()):
                editor = self.tab_widget.widget(i)
                if hasattr(editor, 'file_path') and editor.file_path == file_path:
                    self.tab_widget.setCurrentIndex(i)
                    return
            
            # ファイルを読み込み
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # エディタを作成
            editor = self._add_new_editor(os.path.basename(file_path))
            editor.setPlainText(content)
            editor.file_path = file_path
            editor.document().setModified(False)
            
            # タブを選択
            self.tab_widget.setCurrentWidget(editor)
            
            # 最近のファイルに追加
            self._add_to_recent_files(file_path)
            
            # ステータス更新
            self.status_label.setText(f"ファイルを開きました: {file_path}")
            self._update_file_info()
            
            # イベント発行
            self.file_opened.emit(file_path)
            self.event_system.emit(EventType.FILE_OPENED, {'file_path': file_path})
            
        except Exception as e:
            self.logger.error(f"ファイル読み込みエラー: {e}")
            QMessageBox.critical(self, "エラー", f"ファイルを読み込めませんでした: {e}")
    
    def _save_file(self):
        """現在のファイルを保存"""
        try:
            current_editor = self.tab_widget.currentWidget()
            if not current_editor:
                return
            
            if hasattr(current_editor, 'file_path') and current_editor.file_path:
                # 既存ファイルに保存
                self._save_file_to_path(current_editor, current_editor.file_path)
            else:
                # 名前を付けて保存
                self._save_file_as()
            
        except Exception as e:
            self.logger.error(f"ファイル保存エラー: {e}")
            QMessageBox.critical(self, "エラー", f"ファイルを保存できませんでした: {e}")
    
    def _save_file_as(self):
        """名前を付けてファイルを保存"""
        try:
            current_editor = self.tab_widget.currentWidget()
            if not current_editor:
                return
            
            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "名前を付けて保存",
                "",
                "すべてのファイル (*);;Python ファイル (*.py);;JavaScript ファイル (*.js);;HTML ファイル (*.html);;CSS ファイル (*.css)"
            )
            
            if file_path:
                self._save_file_to_path(current_editor, file_path)
                current_editor.file_path = file_path
                
                # タブタイトルを更新
                index = self.tab_widget.indexOf(current_editor)
                self.tab_widget.setTabText(index, os.path.basename(file_path))
            
        except Exception as e:
            self.logger.error(f"名前を付けて保存エラー: {e}")
            QMessageBox.critical(self, "エラー", f"ファイルを保存できませんでした: {e}")
    
    def _save_file_to_path(self, editor: CodeEditor, file_path: str):
        """指定されたパスにファイルを保存"""
        try:
            content = editor.toPlainText()
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            editor.document().setModified(False)
            
            # 最近のファイルに追加
            self._add_to_recent_files(file_path)
            
            # ステータス更新
            self.status_label.setText(f"ファイルを保存しました: {file_path}")
            self._update_file_info()
            
            # イベント発行
            self.file_saved.emit(file_path)
            self.event_system.emit(EventType.FILE_SAVED, {'file_path': file_path})
            
        except Exception as e:
            self.logger.error(f"ファイル書き込みエラー: {e}")
            raise
    
    # 編集操作メソッド
    def _undo(self):
        """元に戻す"""
        current_editor = self.tab_widget.currentWidget()
        if current_editor:
            current_editor.undo()
    
    def _redo(self):
        """やり直し"""
        current_editor = self.tab_widget.currentWidget()
        if current_editor:
            current_editor.redo()
    
    def _cut(self):
        """切り取り"""
        current_editor = self.tab_widget.currentWidget()
        if current_editor:
            current_editor.cut()
    
    def _copy(self):
        """コピー"""
        current_editor = self.tab_widget.currentWidget()
        if current_editor:
            current_editor.copy()
    
    def _paste(self):
        """貼り付け"""
        current_editor = self.tab_widget.currentWidget()
        if current_editor:
            current_editor.paste()
    
    # プロジェクト操作メソッド
    def _open_project(self):
        """プロジェクトを開く"""
        try:
            project_path = QFileDialog.getExistingDirectory(
                self,
                "プロジェクトフォルダを選択",
                ""
            )
            
            if project_path:
                self._open_project_path(project_path)
            
        except Exception as e:
            self.logger.error(f"プロジェクトオープンエラー: {e}")
            QMessageBox.critical(self, "エラー", f"プロジェクトを開けませんでした: {e}")
    
    def _open_project_path(self, project_path: str):
        """指定されたパスのプロジェクトを開く"""
        try:
            # プロジェクトマネージャーでプロジェクトを開く
            success = self.project_manager.open_project(project_path)
            
            if success:
                self.current_project_path = project_path
                
                # プロジェクトツリーを更新
                self.project_tree.set_root_path(project_path)
                
                # 最近のプロジェクトに追加
                self._add_to_recent_projects(project_path)
                
                # ステータス更新
                self.status_label.setText(f"プロジェクトを開きました: {project_path}")
                
                # ウィンドウタイトル更新
                self.setWindowTitle(f"LLM Code Assistant - {os.path.basename(project_path)}")
                
                # イベント発行
                self.project_opened.emit(project_path)
                self.event_system.emit(EventType.PROJECT_OPENED, {'project_path': project_path})
                
            else:
                QMessageBox.warning(self, "警告", "プロジェクトを開けませんでした")
            
        except Exception as e:
            self.logger.error(f"プロジェクト読み込みエラー: {e}")
            QMessageBox.critical(self, "エラー", f"プロジェクトを読み込めませんでした: {e}")
    
    def _close_project(self):
        """プロジェクトを閉じる"""
        try:
            if self.current_project_path:
                # 未保存の変更をチェック
                if self._check_unsaved_changes():
                    return
                
                # プロジェクトマネージャーでプロジェクトを閉じる
                self.project_manager.close_project()
                
                # UI更新
                self.current_project_path = None
                self.project_tree.clear()
                
                # ウィンドウタイトル更新
                self.setWindowTitle("LLM Code Assistant")
                
                # ステータス更新
                self.status_label.setText("プロジェクトを閉じました")
                
                # イベント発行
                self.project_closed.emit()
                self.event_system.emit(EventType.PROJECT_CLOSED, {})
            
        except Exception as e:
            self.logger.error(f"プロジェクトクローズエラー: {e}")
            QMessageBox.critical(self, "エラー", f"プロジェクトを閉じる際にエラーが発生しました: {e}")
    
    # LLM操作メソッド
    def _select_model(self, model_name: str):
        """LLMモデルを選択"""
        try:
            success = self.llm_factory.set_current_model(model_name)
            
            if success:
                self.model_label.setText(f"モデル: {model_name}")
                self.status_label.setText(f"モデルを変更しました: {model_name}")
                
                # チャットパネルにモデル変更を通知
                self.chat_panel.set_current_model(model_name)
                
            else:
                QMessageBox.warning(self, "警告", f"モデル '{model_name}' を設定できませんでした")
            
        except Exception as e:
            self.logger.error(f"モデル選択エラー: {e}")
            QMessageBox.critical(self, "エラー", f"モデルの選択に失敗しました: {e}")
    
    def _generate_code(self):
        """コード生成"""
        try:
            current_editor = self.tab_widget.currentWidget()
            if not current_editor:
                QMessageBox.information(self, "情報", "コードエディタが開かれていません")
                return
            
            # 選択されたテキストまたは現在の行を取得
            cursor = current_editor.textCursor()
            selected_text = cursor.selectedText()
            
            if not selected_text:
                # 現在の行を取得
                cursor.select(cursor.SelectionType.LineUnderCursor)
                selected_text = cursor.selectedText()
            
            if selected_text.strip():
                # チャットパネルでコード生成を実行
                self.chat_panel.generate_code(selected_text)
                self._show_chat_panel()
            else:
                QMessageBox.information(self, "情報", "コード生成のためのテキストを選択してください")
            
        except Exception as e:
            self.logger.error(f"コード生成エラー: {e}")
            QMessageBox.critical(self, "エラー", f"コード生成に失敗しました: {e}")
    
    def _review_code(self):
        """コードレビュー"""
        try:
            current_editor = self.tab_widget.currentWidget()
            if not current_editor:
                QMessageBox.information(self, "情報", "コードエディタが開かれていません")
                return
            
            # 選択されたテキストまたは全体を取得
            cursor = current_editor.textCursor()
            selected_text = cursor.selectedText()
            
            if not selected_text:
                selected_text = current_editor.toPlainText()
            
            if selected_text.strip():
                # チャットパネルでコードレビューを実行
                self.chat_panel.review_code(selected_text)
                self._show_chat_panel()
            else:
                QMessageBox.information(self, "情報", "レビューするコードがありません")
            
        except Exception as e:
            self.logger.error(f"コードレビューエラー: {e}")
            QMessageBox.critical(self, "エラー", f"コードレビューに失敗しました: {e}")
    
    def _explain_code(self):
        """コード説明"""
        try:
            current_editor = self.tab_widget.currentWidget()
            if not current_editor:
                QMessageBox.information(self, "情報", "コードエディタが開かれていません")
                return
            
            # 選択されたテキストを取得
            cursor = current_editor.textCursor()
            selected_text = cursor.selectedText()
            
            if selected_text.strip():
                # チャットパネルでコード説明を実行
                self.chat_panel.explain_code(selected_text)
                self._show_chat_panel()
            else:
                QMessageBox.information(self, "情報", "説明するコードを選択してください")
            
        except Exception as e:
            self.logger.error(f"コード説明エラー: {e}")
            QMessageBox.critical(self, "エラー", f"コード説明に失敗しました: {e}")
    
    # 表示操作メソッド
    def _select_theme(self, theme_name: str):
        """テーマを選択"""
        try:
            success = self.theme_manager.set_current_theme(theme_name)
            
            if success:
                self._apply_theme()
                self.theme_changed.emit(theme_name)
                self.status_label.setText(f"テーマを変更しました: {theme_name}")
            else:
                QMessageBox.warning(self, "警告", f"テーマ '{theme_name}' を適用できませんでした")
            
        except Exception as e:
            self.logger.error(f"テーマ選択エラー: {e}")
            QMessageBox.critical(self, "エラー", f"テーマの変更に失敗しました: {e}")
    
    def _toggle_project_tree(self):
        """プロジェクトツリーの表示切替"""
        try:
            if self.project_tree.isVisible():
                self.project_tree.hide()
            else:
                self.project_tree.show()
            
        except Exception as e:
            self.logger.error(f"プロジェクトツリー表示切替エラー: {e}")
    
    def _toggle_chat_panel(self):
        """チャットパネルの表示切替"""
        try:
            if self.chat_panel.isVisible():
                self.chat_panel.hide()
            else:
                self.chat_panel.show()
            
        except Exception as e:
            self.logger.error(f"チャットパネル表示切替エラー: {e}")
    
    def _show_chat_panel(self):
        """チャットパネルを表示"""
        try:
            if not self.chat_panel.isVisible():
                self.chat_panel.show()
            
            # フォーカスを設定
            self.chat_panel.focus_input()
            
        except Exception as e:
            self.logger.error(f"チャットパネル表示エラー: {e}")
    
    # ダイアログ表示メソッド
    def _show_settings(self):
        """設定ダイアログを表示"""
        try:
            if not self.settings_dialog:
                self.settings_dialog = SettingsDialog(self)
            
            self.settings_dialog.exec()
            
        except Exception as e:
            self.logger.error(f"設定ダイアログ表示エラー: {e}")
            QMessageBox.critical(self, "エラー", f"設定ダイアログの表示に失敗しました: {e}")
    
    def _show_about(self):
        """バージョン情報ダイアログを表示"""
        try:
            if not self.about_dialog:
                self.about_dialog = AboutDialog(self)
            
            self.about_dialog.exec()
            
        except Exception as e:
            self.logger.error(f"バージョン情報ダイアログ表示エラー: {e}")
            QMessageBox.critical(self, "エラー", f"バージョン情報の表示に失敗しました: {e}")
    
    def _show_find_replace(self):
        """検索・置換ダイアログを表示"""
        try:
            current_editor = self.tab_widget.currentWidget()
            if not current_editor:
                QMessageBox.information(self, "情報", "コードエディタが開かれていません")
                return
            
            if not self.find_replace_dialog:
                self.find_replace_dialog = FindReplaceDialog(self)
            
            self.find_replace_dialog.set_editor(current_editor)
            self.find_replace_dialog.show()
            
        except Exception as e:
            self.logger.error(f"検索・置換ダイアログ表示エラー: {e}")
            QMessageBox.critical(self, "エラー", f"検索・置換ダイアログの表示に失敗しました: {e}")
    
    def _show_user_guide(self):
        """ユーザーガイドを表示"""
        try:
            import webbrowser
            guide_path = os.path.join("docs", "user_guide.md")
            if os.path.exists(guide_path):
                webbrowser.open(f"file://{os.path.abspath(guide_path)}")
            else:
                QMessageBox.information(self, "情報", "ユーザーガイドが見つかりません")
            
        except Exception as e:
            self.logger.error(f"ユーザーガイド表示エラー: {e}")
            QMessageBox.critical(self, "エラー", f"ユーザーガイドの表示に失敗しました: {e}")
    
    def _show_api_reference(self):
        """APIリファレンスを表示"""
        try:
            import webbrowser
            api_path = os.path.join("docs", "api_reference.md")
            if os.path.exists(api_path):
                webbrowser.open(f"file://{os.path.abspath(api_path)}")
            else:
                QMessageBox.information(self, "情報", "APIリファレンスが見つかりません")
            
        except Exception as e:
            self.logger.error(f"APIリファレンス表示エラー: {e}")
            QMessageBox.critical(self, "エラー", f"APIリファレンスの表示に失敗しました: {e}")
    
    # ユーティリティメソッド
    def _add_new_editor(self, title: str = "無題") -> CodeEditor:
        """新しいエディタを追加"""
        try:
            editor = CodeEditor()
            
            # エディタの設定
            editor.document().modificationChanged.connect(self._on_document_modified)
            editor.cursorPositionChanged.connect(self._on_cursor_position_changed)
            
            # タブに追加
            index = self.tab_widget.addTab(editor, title)
            self.tab_widget.setCurrentIndex(index)
            
            return editor
            
        except Exception as e:
            self.logger.error(f"エディタ追加エラー: {e}")
            raise
    
    def _close_tab(self, index: int):
        """タブを閉じる"""
        try:
            editor = self.tab_widget.widget(index)
            
            # 変更されているかチェック
            if editor.document().isModified():
                reply = QMessageBox.question(
                    self,
                    "確認",
                    f"'{self.tab_widget.tabText(index)}' は変更されています。保存しますか？",
                    QMessageBox.StandardButton.Save | 
                    QMessageBox.StandardButton.Discard | 
                    QMessageBox.StandardButton.Cancel
                )
                
                if reply == QMessageBox.StandardButton.Save:
                    self.tab_widget.setCurrentIndex(index)
                    self._save_file()
                elif reply == QMessageBox.StandardButton.Cancel:
                    return
            
            # タブを削除
            self.tab_widget.removeTab(index)
            
            # エディタが空になった場合は新しいエディタを追加
            if self.tab_widget.count() == 0:
                self._add_new_editor("無題")
            
        except Exception as e:
            self.logger.error(f"タブクローズエラー: {e}")
    
    def _close_current_tab(self):
        """現在のタブを閉じる"""
        current_index = self.tab_widget.currentIndex()
        if current_index >= 0:
            self._close_tab(current_index)
    
    def _tab_changed(self, index: int):
        """タブが変更された"""
        try:
            if index >= 0:
                editor = self.tab_widget.widget(index)
                if editor:
                    self._update_file_info()
                    self._on_cursor_position_changed()
            
        except Exception as e:
            self.logger.error(f"タブ変更エラー: {e}")
    
    def _update_file_info(self):
        """ファイル情報を更新"""
        try:
            current_editor = self.tab_widget.currentWidget()
            if current_editor and hasattr(current_editor, 'file_path'):
                file_path = getattr(current_editor, 'file_path', None)
                if file_path:
                    file_size = os.path.getsize(file_path)
                    self.file_info_label.setText(f"サイズ: {file_size} bytes")
                else:
                    self.file_info_label.setText("")
            else:
                self.file_info_label.setText("")
            
        except Exception as e:
            self.logger.error(f"ファイル情報更新エラー: {e}")
    
    def _add_to_recent_files(self, file_path: str):
        """最近のファイルに追加"""
        try:
            if file_path in self.recent_files:
                self.recent_files.remove(file_path)
            
            self.recent_files.insert(0, file_path)
            
            # 最大10件まで保持
            if len(self.recent_files) > 10:
                self.recent_files = self.recent_files[:10]
            
        except Exception as e:
            self.logger.error(f"最近のファイル追加エラー: {e}")
    
    def _add_to_recent_projects(self, project_path: str):
        """最近のプロジェクトに追加"""
        try:
            if project_path in self.recent_projects:
                self.recent_projects.remove(project_path)
            
            self.recent_projects.insert(0, project_path)
            
            # 最大10件まで保持
            if len(self.recent_projects) > 10:
                self.recent_projects = self.recent_projects[:10]
            
        except Exception as e:
            self.logger.error(f"最近のプロジェクト追加エラー: {e}")
    
    def _update_recent_files_menu(self, menu: QMenu):
        """最近のファイルメニューを更新"""
        try:
            menu.clear()
            
            for file_path in self.recent_files:
                if os.path.exists(file_path):
                    action = QAction(os.path.basename(file_path), self)
                    action.setToolTip(file_path)
                    action.triggered.connect(lambda checked, path=file_path: self._open_file_path(path))
                    menu.addAction(action)
            
            if not menu.actions():
                no_recent_action = QAction("最近のファイルなし", self)
                no_recent_action.setEnabled(False)
                menu.addAction(no_recent_action)
            
        except Exception as e:
            self.logger.error(f"最近のファイルメニュー更新エラー: {e}")
    
    def _update_recent_projects_menu(self, menu: QMenu):
        """最近のプロジェクトメニューを更新"""
        try:
            menu.clear()
            
            for project_path in self.recent_projects:
                if os.path.exists(project_path):
                    action = QAction(os.path.basename(project_path), self)
                    action.setToolTip(project_path)
                    action.triggered.connect(lambda checked, path=project_path: self._open_project_path(path))
                    menu.addAction(action)
            
            if not menu.actions():
                no_recent_action = QAction("最近のプロジェクトなし", self)
                no_recent_action.setEnabled(False)
                menu.addAction(no_recent_action)
            
        except Exception as e:
            self.logger.error(f"最近のプロジェクトメニュー更新エラー: {e}")
    
    def _check_unsaved_changes(self) -> bool:
        """未保存の変更があるかチェック"""
        try:
            modified_tabs = []
            
            for i in range(self.tab_widget.count()):
                editor = self.tab_widget.widget(i)
                if editor.document().isModified():
                    modified_tabs.append(self.tab_widget.tabText(i))
            
            if modified_tabs:
                reply = QMessageBox.question(
                    self,
                    "確認",
                    f"以下のファイルが変更されています:\n{', '.join(modified_tabs)}\n\n保存しますか？",
                    QMessageBox.StandardButton.Save | 
                    QMessageBox.StandardButton.Discard | 
                    QMessageBox.StandardButton.Cancel
                )
                
                if reply == QMessageBox.StandardButton.Save:
                    # すべての変更されたファイルを保存
                    for i in range(self.tab_widget.count()):
                        editor = self.tab_widget.widget(i)
                        if editor.document().isModified():
                            self.tab_widget.setCurrentIndex(i)
                            self._save_file()
                    return False
                elif reply == QMessageBox.StandardButton.Cancel:
                    return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"未保存変更チェックエラー: {e}")
            return False
    
    # イベントハンドラ
    def _on_document_modified(self, modified: bool):
        """ドキュメントが変更された"""
        try:
            current_index = self.tab_widget.currentIndex()
            if current_index >= 0:
                current_title = self.tab_widget.tabText(current_index)
                
                if modified and not current_title.endswith("*"):
                    self.tab_widget.setTabText(current_index, current_title + "*")
                elif not modified and current_title.endswith("*"):
                    self.tab_widget.setTabText(current_index, current_title[:-1])
            
        except Exception as e:
            self.logger.error(f"ドキュメント変更ハンドラエラー: {e}")
    
    def _on_cursor_position_changed(self):
        """カーソル位置が変更された"""
        try:
            current_editor = self.tab_widget.currentWidget()
            if current_editor:
                cursor = current_editor.textCursor()
                line = cursor.blockNumber() + 1
                column = cursor.columnNumber() + 1
                self.cursor_label.setText(f"行: {line}, 列: {column}")
            
        except Exception as e:
            self.logger.error(f"カーソル位置変更ハンドラエラー: {e}")
    
    def _on_chat_message(self, message: str):
        """チャットメッセージが送信された"""
        try:
            # 現在のエディタの情報を取得
            current_editor = self.tab_widget.currentWidget()
            context = {}
            
            if current_editor:
                context['current_file'] = getattr(current_editor, 'file_path', None)
                context['selected_text'] = current_editor.textCursor().selectedText()
                context['current_line'] = current_editor.textCursor().blockNumber() + 1
            
            if self.current_project_path:
                context['project_path'] = self.current_project_path
            
            # チャットパネルにコンテキストを設定
            self.chat_panel.set_context(context)
            
        except Exception as e:
            self.logger.error(f"チャットメッセージハンドラエラー: {e}")
    
    def _on_code_generated(self, code: str):
        """コードが生成された"""
        try:
            current_editor = self.tab_widget.currentWidget()
            if current_editor:
                cursor = current_editor.textCursor()
                cursor.insertText(code)
                self.status_label.setText("コードを挿入しました")
            
        except Exception as e:
            self.logger.error(f"コード生成ハンドラエラー: {e}")
    
    def _open_file_from_tree(self, file_path: str):
        """プロジェクトツリーからファイルを開く"""
        try:
            self._open_file_path(file_path)
            
        except Exception as e:
            self.logger.error(f"ツリーからファイルオープンエラー: {e}")
    
    def _on_project_opened(self, project_path: str):
        """プロジェクトが開かれた（プロジェクトツリーから）"""
        try:
            if project_path != self.current_project_path:
                self._open_project_path(project_path)
            
        except Exception as e:
            self.logger.error(f"プロジェクトオープンハンドラエラー: {e}")
    
    # イベントシステムハンドラ
    def _on_file_opened_event(self, data: Dict[str, Any]):
        """ファイルオープンイベント"""
        try:
            file_path = data.get('file_path')
            if file_path:
                self.logger.info(f"ファイルオープンイベント: {file_path}")
            
        except Exception as e:
            self.logger.error(f"ファイルオープンイベントハンドラエラー: {e}")
    
    def _on_file_saved_event(self, data: Dict[str, Any]):
        """ファイル保存イベント"""
        try:
            file_path = data.get('file_path')
            if file_path:
                self.logger.info(f"ファイル保存イベント: {file_path}")
            
        except Exception as e:
            self.logger.error(f"ファイル保存イベントハンドラエラー: {e}")
    
    def _on_project_opened_event(self, data: Dict[str, Any]):
        """プロジェクトオープンイベント"""
        try:
            project_path = data.get('project_path')
            if project_path:
                self.logger.info(f"プロジェクトオープンイベント: {project_path}")
            
        except Exception as e:
            self.logger.error(f"プロジェクトオープンイベントハンドラエラー: {e}")
    
    # 追加のショートカットハンドラ
    def _show_command_palette(self):
        """コマンドパレットを表示"""
        try:
            # TODO: コマンドパレットの実装
            self.status_label.setText("コマンドパレット（未実装）")
            
        except Exception as e:
            self.logger.error(f"コマンドパレット表示エラー: {e}")
    
    def _toggle_fullscreen(self):
        """フルスクリーン切替"""
        try:
            if self.isFullScreen():
                self.showNormal()
            else:
                self.showFullScreen()
            
        except Exception as e:
            self.logger.error(f"フルスクリーン切替エラー: {e}")
    
    def _reopen_closed_tab(self):
        """閉じたタブを再度開く"""
        try:
            # TODO: 閉じたタブの履歴管理と再オープン機能の実装
            self.status_label.setText("閉じたタブを再オープン（未実装）")
            
        except Exception as e:
            self.logger.error(f"タブ再オープンエラー: {e}")
    
    def _new_window(self):
        """新しいウィンドウを開く"""
        try:
            new_window = MainWindow()
            new_window.show()
            
        except Exception as e:
            self.logger.error(f"新しいウィンドウ作成エラー: {e}")
            QMessageBox.critical(self, "エラー", f"新しいウィンドウを作成できませんでした: {e}")
    
    # プログレス表示メソッド
    def show_progress(self, message: str, maximum: int = 0):
        """プログレスバーを表示"""
        try:
            self.progress_bar.setVisible(True)
            self.progress_bar.setMaximum(maximum)
            self.progress_bar.setValue(0)
            self.status_label.setText(message)
            
        except Exception as e:
            self.logger.error(f"プログレス表示エラー: {e}")
    
    def update_progress(self, value: int, message: str = None):
        """プログレスを更新"""
        try:
            self.progress_bar.setValue(value)
            if message:
                self.status_label.setText(message)
            
        except Exception as e:
            self.logger.error(f"プログレス更新エラー: {e}")
    
    def hide_progress(self):
        """プログレスバーを非表示"""
        try:
            self.progress_bar.setVisible(False)
            self.status_label.setText("準備完了")
            
        except Exception as e:
            self.logger.error(f"プログレス非表示エラー: {e}")
    
    # アニメーション関連
    def _create_fade_animation(self, widget: QWidget, duration: int = 300) -> QPropertyAnimation:
        """フェードアニメーションを作成"""
        try:
            animation = QPropertyAnimation(widget, b"windowOpacity")
            animation.setDuration(duration)
            animation.setEasingCurve(QEasingCurve.Type.InOutQuad)
            return animation
            
        except Exception as e:
            self.logger.error(f"フェードアニメーション作成エラー: {e}")
            return None
    
    def _create_slide_animation(self, widget: QWidget, start_pos: QPoint, end_pos: QPoint, duration: int = 300) -> QPropertyAnimation:
        """スライドアニメーションを作成"""
        try:
            animation = QPropertyAnimation(widget, b"pos")
            animation.setDuration(duration)
            animation.setStartValue(start_pos)
            animation.setEndValue(end_pos)
            animation.setEasingCurve(QEasingCurve.Type.InOutQuad)
            return animation
            
        except Exception as e:
            self.logger.error(f"スライドアニメーション作成エラー: {e}")
            return None
    
    # ウィンドウイベント
    def closeEvent(self, event):
        """ウィンドウが閉じられる時の処理"""
        try:
            # 未保存の変更をチェック
            if self._check_unsaved_changes():
                event.ignore()
                return
            
            # 設定を保存
            self._save_settings()
            
            # プロジェクトを閉じる
            if self.current_project_path:
                self.project_manager.close_project()
            
            # リソースをクリーンアップ
            self._cleanup_resources()
            
            event.accept()
            
        except Exception as e:
            self.logger.error(f"ウィンドウクローズエラー: {e}")
            event.accept()  # エラーが発生してもウィンドウを閉じる
    
    def changeEvent(self, event):
        """ウィンドウ状態変更イベント"""
        try:
            if event.type() == event.Type.WindowStateChange:
                if self.isMinimized():
                    # 最小化時の処理
                    pass
                elif self.isMaximized():
                    # 最大化時の処理
                    pass
                elif self.isFullScreen():
                    # フルスクリーン時の処理
                    pass
            
            super().changeEvent(event)
            
        except Exception as e:
            self.logger.error(f"ウィンドウ状態変更エラー: {e}")
    
    def resizeEvent(self, event):
        """ウィンドウリサイズイベント"""
        try:
            super().resizeEvent(event)
            
            # リサイズ時の追加処理があれば実装
            
        except Exception as e:
            self.logger.error(f"ウィンドウリサイズエラー: {e}")
    
    def _cleanup_resources(self):
        """リソースをクリーンアップ"""
        try:
            # アニメーションを停止
            for animation in self.animations.values():
                if animation.state() == QPropertyAnimation.State.Running:
                    animation.stop()
            
            # ダイアログを閉じる
            dialogs = [
                self.settings_dialog,
                self.about_dialog,
                self.progress_dialog,
                self.find_replace_dialog
            ]
            
            for dialog in dialogs:
                if dialog and dialog.isVisible():
                    dialog.close()
            
            # イベントシステムから購読解除
            self.event_system.unsubscribe_all(self)
            
            self.logger.info("リソースをクリーンアップしました")
            
        except Exception as e:
            self.logger.error(f"リソースクリーンアップエラー: {e}")
    
    # パブリックメソッド
    def get_current_editor(self) -> Optional[CodeEditor]:
        """現在のエディタを取得"""
        return self.tab_widget.currentWidget()
    
    def get_current_file_path(self) -> Optional[str]:
        """現在のファイルパスを取得"""
        current_editor = self.get_current_editor()
        if current_editor and hasattr(current_editor, 'file_path'):
            return current_editor.file_path
        return None
    
    def get_current_project_path(self) -> Optional[str]:
        """現在のプロジェクトパスを取得"""
        return self.current_project_path
    
    def set_status_message(self, message: str, timeout: int = 0):
        """ステータスメッセージを設定"""
        try:
            if timeout > 0:
                self.statusBar().showMessage(message, timeout)
            else:
                self.status_label.setText(message)
            
        except Exception as e:
            self.logger.error(f"ステータスメッセージ設定エラー: {e}")
    
    def add_editor_tab(self, title: str, content: str = "", file_path: str = None) -> CodeEditor:
        """エディタタブを追加"""
        try:
            editor = self._add_new_editor(title)
            
            if content:
                editor.setPlainText(content)
                editor.document().setModified(False)
            
            if file_path:
                editor.file_path = file_path
            
            return editor
            
        except Exception as e:
            self.logger.error(f"エディタタブ追加エラー: {e}")
            raise
    
    def get_all_editors(self) -> List[CodeEditor]:
        """すべてのエディタを取得"""
        editors = []
        for i in range(self.tab_widget.count()):
            editor = self.tab_widget.widget(i)
            if isinstance(editor, CodeEditor):
                editors.append(editor)
        return editors
    
    def close_all_tabs(self):
        """すべてのタブを閉じる"""
        try:
            # 未保存の変更をチェック
            if self._check_unsaved_changes():
                return
            
            # すべてのタブを削除
            while self.tab_widget.count() > 0:
                self.tab_widget.removeTab(0)
            
            # 新しいエディタを追加
            self._add_new_editor("無題")
            
        except Exception as e:
            self.logger.error(f"全タブクローズエラー: {e}")
            QMessageBox.critical(self, "エラー", f"タブを閉じる際にエラーが発生しました: {e}")


# メインウィンドウのファクトリ関数
def create_main_window() -> MainWindow:
    """メインウィンドウを作成"""
    try:
        return MainWindow()
    except Exception as e:
        logger.error(f"メインウィンドウ作成エラー: {e}")
        raise


if __name__ == "__main__":
    # テスト用のメイン関数
    app = QApplication(sys.argv)
    
    try:
        window = create_main_window()
        window.show()
        sys.exit(app.exec())
        
    except Exception as e:
        print(f"アプリケーション実行エラー: {e}")
        sys.exit(1)
